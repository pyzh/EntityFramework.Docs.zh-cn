---
title: 在团队环境的 EF6 code First 迁移
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 53460b6cdd454099ccf93b4e2133e4ea21278a64
ms.sourcegitcommit: fa863883f1193d2118c2f9cee90808baa5e3e73e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/04/2018
ms.locfileid: "52857463"
---
# <a name="code-first-migrations-in-team-environments"></a>在团队环境中的 code First 迁移
> [!NOTE]
> 本文假定你知道如何在基本方案中使用 Code First 迁移。 如果不这样做，则你将需要读取[Code First 迁移](~/ef6/modeling/code-first/migrations/index.md)然后再继续。

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>不要着急，您需要阅读此整篇文章

主要是关于合并两个开发人员已在其本地代码库中生成迁移时迁移是在团队环境中的问题。 非常简单的步骤来解决这些时，它们需要你已迁移的工作原理的深入了解。 请不要只是往前跳到最后 – 花时间阅读整篇文章中，以确保成功。

## <a name="some-general-guidelines"></a>一些通用准则

在我们深入了解到如何管理由多个开发人员生成的合并迁移之前，以下是一些通用准则，以获得成功。

### <a name="each-team-member-should-have-a-local-development-database"></a>每个团队成员应具有一个本地开发数据库

迁移使用 **\_ \_MigrationsHistory**用于存储已应用哪些迁移到数据库表。 如果有多个开发人员尝试以相同的数据库为目标时生成不同的迁移 (并因此共享 **\_ \_MigrationsHistory**表) 迁移会感到很困惑。

当然，如果你的团队成员不会生成迁移，是让它们共享一个中央开发数据库没问题。

### <a name="avoid-automatic-migrations"></a>避免自动迁移

底线是自动迁移最初看起来在团队环境中，很好，但实际上它们只是不起作用。 如果你想要知道原因，往下读 – 如果没有，则可以跳过到下一节。

自动迁移，你可以在数据库架构已更新以匹配当前模型而无需生成代码文件 （基于代码的迁移）。 如果只使用它们，并且永远不生成任何基于代码的迁移，自动迁移将在团队环境中很好地进行工作。 问题是，自动迁移限制，并且不处理多个操作 – 属性/列重命名、 将数据移到另一个表，等等。若要处理这些方案，最终会生成基于代码的迁移 （和编辑基架的代码） 的混合之间由自动迁移的更改。 这使得它附近上是不可能将更改合并两个开发人员签入迁移时。

## <a name="screencasts"></a>屏幕广播

如果您而是将观看截屏视频比阅读这篇文章时，以下两个视频涵盖的内容与这篇文章相同。

### <a name="video-one-migrations---under-the-hood"></a>视频的一个:"迁移-实质上"

[此截屏视频](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood)介绍了如何迁移跟踪和使用有关模型的信息来检测模型更改。

### <a name="video-two-migrations---team-environments"></a>视频 2:"迁移的团队环境"

在上一视频中，从概念上构建[此截屏视频](http://channel9.msdn.com/blogs/ef/migrations-team-environments)介绍了在团队环境以及如何解决这些问题出现的问题。

## <a name="understanding-how-migrations-works"></a>了解如何迁移的工作原理

已成功在团队环境中使用迁移的关键是一个基本了解如何迁移跟踪和使用有关模型的信息来检测模型更改。

### <a name="the-first-migration"></a>第一次迁移

当将第一次迁移添加到你的项目时，运行以下**添加迁移第一个**包管理器控制台中。 此命令执行的高级别步骤将如下图所示。

![第一次迁移](~/ef6/media/firstmigration.png)

当前模型会计算从你的代码 (1)。 然后，所需的数据库对象的计算方法是模型的区别 (2) – 由于这是第一次迁移模型不同只需使用用于比较的空模型。 所需的更改将传递给代码生成器以生成随后将添加到 Visual Studio 解决方案 (4) 的需要的迁移代码 (3)。

除了存储在主代码文件中的实际迁移代码，迁移还会生成一些额外的代码隐藏文件。 这些文件是由迁移的元数据，而不应编辑的内容。 这些文件之一是模型的在迁移的生成的时间包含快照的资源文件 (.resx)。 您将看到如何使用此方法在下一步。

此时可能会运行**Update-database**应用到数据库，所做的更改，然后转有关实现你的应用程序的其他区域。

### <a name="subsequent-migrations"></a>以后的迁移

回到，对模型进行一些更改 – 在本例中我们将添加更高版本**Url**属性设置为**博客**。 然后将如发出命令**Add-migration AddUrl**搭建基架，迁移，以将相应的数据库应用更改。 此命令执行的高级别步骤将如下图所示。

![第二次迁移](~/ef6/media/secondmigration.png)

只需按前面所述，当前模型会计算从代码 (1)。 但是，这一次有现有迁移以便以前的模型中检索最新的迁移 (2) 中。 这两种模型是那样来查找所需的数据库更改 (3)，则该过程完成像以前一样。

这一过程用于向项目添加任何进一步迁移。

### <a name="why-bother-with-the-model-snapshot"></a>为什么要费力的模型快照？

您可能想知道为什么 EF 麻烦的模型快照-为什么不只是查看数据库。 如果是这样，继续阅读。 如果您不感兴趣则可以跳过此部分。

有多种原因而 EF 将周围的模型快照：

-   它允许您以不符合 EF 模型的数据库。 可以直接在数据库中，进行这些更改也可以更改基架的代码中你迁移，以便进行所做的更改。 下面是几个在实践中的此示例：
    -   你想要添加到一个或多个表的列的插入和更新，但不想要在 EF 模型中包含这些列。 如果迁移介绍了它会不断地尝试删除这些列，每次在已迁移搭建基架的数据库。 使用的模型快照，EF 只会将检测对模型的合法更改。
    -   你想要更改存储过程用于更新以包括一些日志记录的正文。 如果迁移介绍了此存储过程从数据库它将不断尝试和其重置回 EF 所需的定义。 通过使用模型快照，EF 将只会创建基架的代码来更改存储的过程，当更改形状的 EF 模型中的过程。
    -   这些原理同样适用于添加额外的索引，在数据库中包括其他表、 将 EF 映射到数据库视图位于通过一个表，等等。
-   EF 模型包含多个只是数据库的形状。 使整个模型，可以迁移，以便查看有关的属性和您的模型以及它们如何映射到列和表中的类的信息。 此信息使迁移要在代码中，它搭建基架以更智能。 例如，如果您更改某个属性将映射迁移到的列的名称可以检测通过重命名，看看它是同一属性 – 如果你只有数据库架构不能完成的内容。 

## <a name="what-causes-issues-in-team-environments"></a>什么会导致在团队环境中的问题

工作流时使用的应用程序上的单个开发人员介绍前面的部分非常好。 它也适用于在团队环境中是唯一的用户对模型进行更改。 在此方案中可以进行模型更改，生成迁移并将其提交到源代码管理。 其他开发人员可以同步所做的更改并运行**Update-database**使架构更改应用。

开始时有多个开发人员对 EF 模型进行更改并提交到源代码管理在同一时间出现问题。 EF 缺少是一种合并与其他开发人员在自上次同步以来已提交到源代码管理的迁移本地迁移的第一类方法。

## <a name="an-example-of-a-merge-conflict"></a>举例说明了合并冲突

第一个让我们看看一个具体示例的合并冲突。 我们将继续上与我们在前面的示例。 作为起始点让我们假设由原始的开发人员签入上一节中的更改。 当它们更改代码基，我们将跟踪两个开发人员。

EF 模型和数更改通过迁移，我们将跟踪。 对于起始点，这两个开发人员已同步到源控件存储库，下, 图中所示。

![起始点](~/ef6/media/startingpoint.png)

开发人员\#1 和开发人员\#2 现在对某些更改其本地代码中的 EF 模型基。 开发人员\#1 添加了**评级**属性设置为**博客**– 并生成**AddRating**迁移，以应用到数据库所做的更改。 开发人员\#2 添加**读者**属性设置为**博客**– 并生成相应**AddReaders**迁移。 这两个开发人员运行**Update-database**，以将所做的更改应用到其本地数据库，然后继续开发应用程序。

> [!NOTE]
> 迁移前面都加有时间戳，因此我们的图形表示从开发人员的 AddReaders 迁移\#2 来自 AddRating 迁移后开发人员\#1。 是否开发人员\#1 或\#2 生成第一个建立的迁移工作在一个团队或合并他们，我们将介绍下一节中的过程中的问题没有影响。

![本地更改](~/ef6/media/localchanges.png)

它为开发人员幸运日\#1 发生时将其更改提交第一次。 任何其他人已签入，因为它们同步其存储库，因为它们只是可以无需执行任何合并提交他们的更改。

![提交](~/ef6/media/submit.png)

现在，开发人员\#2 提交。 他们不是那么幸运。 其他人已提交的更改，因为它们同步，因为它们将需要展开下拉列表的更改和合并。 源代码管理系统可能将能够自动合并代码级别的更改，因为它们是非常简单。 开发人员的状态\#2 的本地存储库后同步在下图中所示。 

![请求](~/ef6/media/pull.png)

在此阶段开发人员\#2 可以运行**Update-database**其将检测新**AddRating**迁移 (其中未应用到开发人员\#2 的数据库) 并将其应用。 现在**评级**列添加到**博客**该表和数据库是与模型同步。

但有以下几个问题：

1.  尽管**Update-database**将应用**AddRating**迁移也将引发警告：*无法更新数据库以匹配当前模型，因为有挂起的更改和禁用自动迁移...*
    问题是中的最后一个迁移存储的模型快照 (**AddReader**) 缺少**评级**属性上的**博客**(因为它不是模型的一部分时迁移已生成）。 代码首先检测到的最后一个迁移中的模型不匹配当前模型，并且会引发警告。
2.  运行应用程序将导致 InvalidOperationException 消息，指出"*支持 bloggingcontext 上下文的模型创建数据库后已更改。请考虑使用 Code First 迁移更新数据库..."*
    同样，问题是中的最后一个迁移存储的模型快照与当前模型不匹配。
3.  最后，我们期望运行**Add-migration** （因为没有要应用于数据库的更改），现在就会生成空迁移。 但是，由于迁移到的最后一个迁移从一个比较当前模型 (即缺失**评级**属性) 它将实际创建基架另一个**AddColumn** 中添加调用**评级**列。 当然，此迁移将失败期间**Update-database**因为**评级**列已存在。

## <a name="resolving-the-merge-conflict"></a>解决合并冲突

好消息是，它不太难应对合并手动 – 提供你已迁移的工作原理的了解。 因此，如果您已跳过了此部分... 很抱歉，你需要返回并首先阅读本文的其余部分 ！

有两个选项，最简单的方法是生成具有正确的当前模型为以快照形式的空白迁移。 第二个选项是更新的快照中的最后一个迁移以具有正确的模型快照。 第二个选项是有点困难，不能使用在每个方案中，但它也是更简洁因为它不涉及添加额外的迁移。

### <a name="option-1-add-a-blank-merge-migration"></a>选项 1： 添加空白合并的迁移

在此选项中我们生成空白迁移专门用于确保最新的迁移都是正确的模型快照存储在其中。

此选项可以使用而不考虑用户生成的最后一个迁移。 在示例中我们已遵循开发人员\#2 会负责合并和生成的最后一个迁移发生。 但可以使用这些相同的步骤，如果开发人员\#1 生成的最后一个迁移。 如果有多个迁移涉及 – 我们只介绍了在两个以使其保持简单，步骤也适用。

以下过程可以用于这种方法，从您意识到需要进行更改，需要从源代码管理同步的时间开始。

1.  请确保您的本地代码库中的任何挂起的模型更改已写入迁移。 此步骤可确保生成空白迁移时，不要错过合法的任何更改。
2.  与源代码管理同步。
3.  运行**Update-database**来应用其他开发人员在签入任何新迁移。
    **_注意：_**  *如果不更新数据库命令中获取所有警告并没有任何其他开发人员的新迁移和无需执行任何合并。*
4.  运行**Add-migration&lt;选取\_\_名称&gt;– IgnoreChanges** (例如， **Add-migration 合并 – IgnoreChanges**)。 这与 （包括当前模型的快照） 的所有元数据生成迁移，但将忽略比较当前模型到最后一个迁移中的快照时检测到的任何更改 (这意味着获取空白**向上**和**向下**方法)。
5.  在继续开发，或者 （后运行单元测试当然） 提交到源代码管理。

下面是开发人员的状态\#2 的本地代码库后使用此方法。

![合并迁移](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>选项 2： 更新中的最后一个迁移的模型快照

此选项与选项 1 非常相似，但可消除额外的空白迁移 –，因为我们面对现实吧，希望在其解决方案中的额外的代码文件。

**如果最新迁移仅在您的本地代码库中存在，并且有尚未提交到源代码管理 （例如，如果由用户执行合并生成的最后一个迁移），这种方法才可行**。 编辑元数据的迁移的其他开发人员可能已应用到其开发数据库 – 甚至更糟糕的是应用于生产数据库可能会导致意外的副作用。 在过程中我们将回滚我们本地数据库中的最后一个迁移并重新将其应用与更新的元数据。

而最后一个迁移需要只是为本地代码库的数量或顺序继续其迁移到没有限制。 可以有多个不同的开发人员从多个迁移和步骤同样适用 – 我们只介绍了在两个以使其保持简单。

以下过程可以用于这种方法，从您意识到需要进行更改，需要从源代码管理同步的时间开始。

1.  请确保您的本地代码库中的任何挂起的模型更改已写入迁移。 此步骤可确保生成空白迁移时，不要错过合法的任何更改。
2.  与源代码管理同步。
3.  运行**Update-database**来应用其他开发人员在签入任何新迁移。
    **_注意：_**  *如果不更新数据库命令中获取所有警告并没有任何其他开发人员的新迁移和无需执行任何合并。*
4.  运行**更新数据库 – TargetMigration&lt;第二个\_上次\_迁移&gt;** (这是在示例中我们已一直关注**更新数据库 –TargetMigration AddRating**)。 此角色在数据库返回的第二个状态上次迁移 – 有效地未应用从数据库的最后一个迁移。
    **_注意：_**  *需要此步骤以使安全地编辑元数据的迁移，因为元数据也存储在\_ \_MigrationsHistoryTable 的数据库。这就是原因仅在你本地代码库中的最后一个迁移时，应仅使用此选项。如果其他数据库的应用的最后一个迁移将具有它们回滚并重新应用更新元数据的最后一个迁移。* 
5.  运行**Add-migration&lt;完整\_名称\_包括\_时间戳\_的\_最后一个\_迁移**&gt; （在本例中我们已一直关注这将是类似**Add-migration 201311062215252\_AddReaders**)。
    **_注意：_**  *需要包含时间戳，以便让迁移知道你想要编辑现有的迁移，而不是一个新的基架。*
    这会更新以匹配当前模型的最后一个迁移的元数据。 该命令完成，但这正是你想时，你将收到以下警告。 "*设计器代码仅迁移"201311062215252\_AddReaders' 已重新已搭建基架。若要重新创建整个迁移基架，请使用-Force 参数。"*
6.  运行**Update-database**重新应用迁移的最新过程中更新的元数据。
7.  在继续开发，或者 （后运行单元测试当然） 提交到源代码管理。

下面是开发人员的状态\#2 的本地代码库后使用此方法。

![更新的元数据](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>总结

在团队环境中使用 Code First 迁移时，有一些难题。 但是，基本了解迁移的工作原理和解决合并冲突一些简单的方法轻松地解决这些难题。

基本问题是不正确的元数据存储在最新的迁移。 这将导致代码第一个错误地检测不匹配当前模型和数据库架构和搭建基架，在下一步的迁移中的代码不正确。 可以通过生成具有正确的模型，空白迁移或更新最新的迁移中的元数据来克服这种情况。
